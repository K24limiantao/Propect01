'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = hrbacPlugin;

var _union = require('lodash/union');

var _union2 = _interopRequireDefault(_union);

var _indexOf = require('lodash/indexOf');

var _indexOf2 = _interopRequireDefault(_indexOf);

var _without = require('lodash/without');

var _without2 = _interopRequireDefault(_without);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function getScope(rbac, cb) {
  var permissions = this.permissions || [];

  rbac.getScope(this.role, function (err, scope) {
    if (err) {
      return cb(err);
    }

    var newScope = (0, _union2.default)(permissions, scope);
    return cb(null, newScope);
  });

  return this;
}

/**
 * Check if user has assigned a specific permission
 * @param  {RBAC}  rbac Instance of RBAC
 * @param  {String}   action  Name of action
 * @param  {String}   resource  Name of resource
 * @return {Boolean}
 */
function can(rbac, action, resource, cb) {
  var _this = this;

  // check existance of permission
  rbac.getPermission(action, resource, function (err, permission) {
    if (err) {
      return cb(err);
    }

    if (!permission) {
      return cb(null, false);
    }

    // check user additional permissions
    if ((0, _indexOf2.default)(_this.permissions, permission.name) !== -1) {
      return cb(null, true);
    }

    if (!_this.role) {
      return cb(null, false);
    }

    // check permission inside user role
    return rbac.can(_this.role, action, resource, cb);
  });

  return this;
}

/**
 * Assign additional permissions to the user
 * @param  {String|Array}   permissions  Array of permissions or string representing of permission
 * @param  {Function} cb Callback
 */
function addPermission(rbac, action, resource, cb) {
  var _this2 = this;

  rbac.getPermission(action, resource, function (err, permission) {
    if (err) {
      return cb(err);
    }

    if (!permission) {
      return cb(new Error('Permission not exists'));
    }

    if ((0, _indexOf2.default)(_this2.permissions, permission.name) !== -1) {
      return cb(new Error('Permission is already assigned'));
    }

    _this2.permissions.push(permission.name);
    return _this2.save(function (err2, user) {
      if (err2) {
        return cb(err2);
      }

      if (!user) {
        return cb(new Error('User is undefined'));
      }

      return cb(null, true);
    });
  });

  return this;
}

function removePermission(permissionName, cb) {
  if ((0, _indexOf2.default)(this.permissions, permissionName) === -1) {
    cb(new Error('Permission was not asssigned'));
    return this;
  }

  this.permissions = (0, _without2.default)(this.permissions, permissionName);
  this.save(function (err, user) {
    if (err) {
      return cb(err);
    }

    if (!user) {
      return cb(new Error('User is undefined'));
    }

    if ((0, _indexOf2.default)(user.permissions, permissionName) !== -1) {
      return cb(new Error('Permission was not removed'));
    }

    return cb(null, true);
  });

  return this;
}

function removePermissionFromCollection(permissionName, cb) {
  this.update({
    permissions: permissionName
  }, {
    $pull: {
      permissions: permissionName
    }
  }, {
    multi: true
  }, function (err, num) {
    if (err) {
      return cb(err);
    }

    return cb(null, true);
  });

  return this;
}

/**
 * Check if user has assigned a specific role
 * @param  {RBAC}  rbac Instance of RBAC
 * @param  {String}  name Name of role
 * @return {Boolean}      [description]
 */
function hasRole(rbac, role, cb) {
  if (!this.role) {
    cb(null, false);
    return this;
  }

  // check existance of permission
  rbac.hasRole(this.role, role, cb);
  return this;
}

function removeRole(cb) {
  if (!this.role) {
    cb(null, false);
    return this;
  }

  this.role = null;
  this.save(function (err, user) {
    if (err) {
      return cb(err);
    }

    if (!user) {
      return cb(new Error('User is undefined'));
    }

    return cb(null, user.role === null);
  });

  return this;
}

function removeRoleFromCollection(roleName, cb) {
  this.update({
    role: roleName
  }, {
    role: null
  }, {
    multi: true
  }, function (err, num) {
    if (err) {
      return cb(err);
    }

    return cb(null, true);
  });

  return this;
}

function setRole(rbac, role, cb) {
  var _this3 = this;

  if (this.role === role) {
    cb(new Error('User already has assigned this role'));
    return this;
  }

  // check existance of permission
  rbac.getRole(role, function (err, role) {
    if (err) {
      return cb(err);
    }

    if (!role) {
      return cb(new Error('Role does not exists'));
    }

    _this3.role = role.name;
    return _this3.save(function (err2, user) {
      if (err2) {
        return cb(err2);
      }

      if (!user) {
        return cb(new Error('User is undefined'));
      }

      return cb(null, user.role === _this3.role);
    });
  });

  return this;
}

function hrbacPlugin(schema) {
  var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

  schema.add({
    role: {
      type: String,
      default: options.defaultRole
    },
    permissions: {
      type: [String],
      default: options.defaultPermissions
    }
  });

  schema.methods.can = can;

  schema.methods.addPermission = addPermission;
  schema.methods.removePermission = removePermission;

  schema.methods.hasRole = hasRole;
  schema.methods.removeRole = removeRole;
  schema.methods.setRole = setRole;

  schema.methods.getScope = getScope;

  schema.statics.removeRoleFromCollection = removeRoleFromCollection;
  schema.statics.removePermissionFromCollection = removePermissionFromCollection;
}